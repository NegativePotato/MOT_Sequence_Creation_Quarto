---
title: "MOT_Sequence_Target_Density"
author: "Freya Joessel"
editor: source
date: today
toc: true
toc-depth: 5
# toc-expand: true
number-sections: true
highlight-style: pygments
toc-location: left
reference-location: margin
citation-location: margin
format:
  html: 
    code-fold: true
    html-math-method: katex
---


```{r preamble}
#| echo: false
#| include: false

library(dplyr)
library(progress)
library(ggplot2)
library(purrr)
library(parallel)

```


```{r load-data}
#| echo: false
#| cache: true
#| include: false

density_per_frame_tables_all.df <- readRDS(file = "Tables/density_per_frame_tables_all.rds")

```


# Task Parameters

```{r task-parameters}
#| echo: false
#| include: false

n_targets_in_experiment <- 5

tracking_duration_s <- 4
trial_duration_s <- 6
probing_duration <- trial_duration_s - tracking_duration_s
trial_n_frames <- max(density_per_frame_tables_all.df$frame_num)
probing_n_frames <- probing_duration*(trial_n_frames - 1)/trial_duration_s + 1
tracking_n_frames <- trial_n_frames - probing_n_frames

```

We opt for N targets to track = `r n_targets_in_experiment` to have enough room above and below the typical performance of young adults at this variant of the MOT task (around 75% - Green and Bavelier (2006)). 


# Target Density Low/High Throughout

## Finding sets of circles with low/high density with themselves

```{r compute-density-within-subsets-function}
#| echo: false
#| include: false
#| cache: true

# density_per_frame_tables_for_claude.df <- density_per_frame_tables_all.df %>% 
#   filter(trial_num <= 10, i_dataset == 1) %>% 
#   select(i_dataset, trial_num, frame_num, circle_num, x_coord, y_coord)
# write.csv(x = density_per_frame_tables_for_claude.df, 
#           file = "Tables/density_per_frame_table_for_claude.csv", 
#           row.names = F)

# ─────────────────────────────────────────────
# 1. Function
# ─────────────────────────────────────────────

compute_target_density <- function(data, target_set, start_frame, end_frame, log_file = NULL) {
  
  set_label <- paste(target_set, collapse = "-")
  
  # Helper to write a timestamped line to this worker's dedicated log file
  log_msg <- function(msg) {
    if (!is.null(log_file)) {
      cat(sprintf("%s | %s\n", format(Sys.time(), "%Y-%m-%d %H:%M:%S"), msg),
          file = log_file, append = TRUE)
    }
  }
  
  # Pre-filter to relevant frames for efficiency
  data_filtered <- data %>%
    filter(frame_num >= start_frame, 
           frame_num <= end_frame, 
           circle_num %in% target_set)
  
  # Get unique trials to iterate over and log per-trial progress
  trials <- data_filtered %>%
    select(i_dataset, trial_num) %>%
    distinct()
  
  log_msg(sprintf("[Set %s] Starting — %d trials to process", set_label, nrow(trials)))
  
  trial_results <- lapply(1:nrow(trials), function(t) {
    i_ds  <- trials$i_dataset[t]
    i_tr  <- trials$trial_num[t]
    
    # Log at the start of each trial within each set
    log_msg(sprintf("[Set %s] Starting dataset %d, trial %d (%d / %d)",
                    set_label, i_ds, i_tr, t, nrow(trials)))
    
    trial_data <- data_filtered %>%
      filter(i_dataset == i_ds, trial_num == i_tr)
    
    trial_data %>%
      group_by(frame_num, circle_num) %>%
      group_modify(~ {
        current_circle <- .x
        
        target_coords <- trial_data %>%
          filter(frame_num   == .y$frame_num,
                 circle_num %in% target_set)
        
        target_density <- target_coords %>%
          mutate(dist = sqrt((x_coord - current_circle$x_coord)^2 +
                               (y_coord - current_circle$y_coord)^2)) %>%
          pull(dist) %>%
          sum()
        
        .x %>% mutate(target_density = target_density)
      }) %>%
      ungroup() %>%
      mutate(i_dataset = i_ds, trial_num = i_tr)
  })
  
  density_df <- bind_rows(trial_results) %>%
    mutate(target_set = set_label)
  
  log_msg(sprintf("[Set %s] Done", set_label))
  
  return(density_df)
}


compute_target_density_wrapper <- function(data, target_sets, start_frame, end_frame,
                                           cache_dir = "cache/",
                                           log_dir   = "logs/") {
  
  # Option 3: create cache directory to store one .rds per completed set
  dir.create(cache_dir, showWarnings = FALSE)
  # Create log directory — each worker will write to its own log file
  dir.create(log_dir, showWarnings = FALSE)
  
  # Skip sets that are already cached (crash recovery)
  target_sets_todo <- Filter(function(s) {
    !file.exists(file.path(cache_dir, paste0(paste(s, collapse = "-"), ".rds")))
  }, target_sets)
  
  n_done <- length(target_sets) - length(target_sets_todo)
  message(sprintf("%d / %d sets already cached. %d remaining.",
                  n_done, length(target_sets), length(target_sets_todo)))
  
  if (length(target_sets_todo) > 0) {
    n_cores <- detectCores() - 3  # leave 3 core free for the OS
    cl <- makeCluster(n_cores)
    
    tryCatch({
      # Export everything the workers need
      clusterExport(cl, varlist = c("compute_target_density", "data", "start_frame",
                                    "end_frame", "cache_dir", "log_dir"),
                    envir = environment())
      clusterEvalQ(cl, library(dplyr))
      
      # Assign each worker a dedicated log file named by its PID
      clusterEvalQ(cl, {
        worker_log_file <<- file.path(log_dir, sprintf("worker_%d.log", Sys.getpid()))
      })
      
      parLapply(cl, target_sets_todo, function(target_set) {
        result <- compute_target_density(
          data        = data,
          target_set  = target_set,
          start_frame = start_frame,
          end_frame   = end_frame,
          log_file    = worker_log_file)   # each worker uses its own log file
        # Option 3: save result to cache as soon as this set is done
        saveRDS(result,
                file = file.path(cache_dir, paste0(paste(target_set, collapse = "-"), ".rds")))
      })
    }, finally = {
      stopCluster(cl)
    })
  }
  
  # Read all cached results and combine
  # Write a summary line to a main log so you know when the job finished
  cat(sprintf("%s | All sets complete. Reading cache and combining results...\n",
              format(Sys.time(), "%Y-%m-%d %H:%M:%S")),
      file = file.path(log_dir, "main.log"), append = TRUE)
  all_files <- list.files(cache_dir, pattern = "\\.rds$", full.names = TRUE)
  target_density_per_frame.df <- bind_rows(lapply(all_files, readRDS))
  
  return(target_density_per_frame.df)
}


```

```{r compute-density-within-subsets-parameters}
#| echo: false
#| include: false
#| cache: true

# ─────────────────────────────────────────────
# 2. Run for all target sets and combine
# ─────────────────────────────────────────────

target_sets <- combn(16, 5, simplify = F)

n_target_sets <- length(unlist(target_sets))


start_frame <- 1
end_frame <- trial_n_frames  
n_frames <- (end_frame - start_frame + 1)


```

```{r compute-density-within-subsets-below-threshold-trials}
#| echo: false
#| include: false
#| cache: true

density_per_frame_tables_below_throughout.df <- 
  readRDS(file = "Tables/density_per_frame_tables_below_throughout.rds")

n_trials_below <- nrow(unique(density_per_frame_tables_below_throughout.df %>%
                                       select(i_dataset, trial_num)))

target_density_per_frame_tables_below_throughout.df <- 
  compute_target_density_wrapper(
    data        = density_per_frame_tables_below_throughout.df, 
    target_sets = target_sets, 
    start_frame = start_frame, 
    end_frame   = end_frame,
    cache_dir   = "cache/",
    log_dir     = "logs/")


write.csv(target_density_per_frame_tables_below_throughout.df, 
          file = "Tables/target_density_per_frame_tables_below_throughout.csv", 
          row.names = F)
saveRDS(target_density_per_frame_tables_below_throughout.df, 
        file = "Tables/target_density_per_frame_tables_below_throughout.rds")


```




